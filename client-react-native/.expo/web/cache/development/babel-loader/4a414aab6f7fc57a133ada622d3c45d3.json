{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport { loadAsync } from 'expo-font';\nexport function useFonts(map) {\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      loaded = _useState2[0],\n      setLoaded = _useState2[1];\n\n  useEffect(function () {\n    loadAsync(map).then(function () {\n      return setLoaded(true);\n    });\n  }, []);\n  return [loaded];\n}","map":{"version":3,"sources":["use-fonts.ts"],"names":["useState","useEffect","loadAsync","setLoaded"],"mappings":";AAAA,SAAA,SAAA,EAAA,QAAA,QAAA,OAAA;AACA,SAAA,SAAA,QAAA,WAAA;AAYA,OAAO,SAAA,QAAA,CAAA,GAAA,EAA2C;AACjD,kBAA4BA,QAAQ,CAApC,KAAoC,CAApC;AAAA;AAAA,MAAM,MAAN;AAAA,MAAM,SAAN;;AAEAC,EAAAA,SAAS,CAAC,YAAM;AACfC,IAAAA,SAAS,CAATA,GAAS,CAATA,CAAAA,IAAAA,CAAoB;AAAA,aAAMC,SAAS,CAAnCD,IAAmC,CAAf;AAAA,KAApBA;AADQ,GAAA,EAHwC,EAGxC,CAATD;AAQA,SAAO,CAAP,MAAO,CAAP;AACA","sourcesContent":["import { useEffect, useState } from 'react';\nimport { FontSource, loadAsync } from 'expo-font';\n\n/**\n * Load a map of custom fonts to use in textual elements.\n * The map keys are used as font names, and can be used with `fontFamily: <name>;`.\n * It returns a boolean describing if all fonts are loaded.\n *\n * Note, the fonts are not \"reloaded\" when you dynamically change the font map.\n *\n * @see https://docs.expo.io/versions/latest/sdk/font/\n * @example const [isLoaded] = useFonts(...);\n */\nexport function useFonts(map: FontMap): [boolean] {\n\tconst [loaded, setLoaded] = useState(false);\n\n\tuseEffect(() => {\n\t\tloadAsync(map).then(() => setLoaded(true))\n\t}, []); // eslint-disable-line\n\n\t// note: to avoid any ambiguity fonts are only loaded once\n\t// since every rerender is a new object, we have no way of\n\t// detecting a new map and updating the loaded state based on that\n\n\treturn [loaded];\n}\n\ninterface FontMap {\n\t[name: string]: FontSource;\n}\n"]},"metadata":{},"sourceType":"module"}